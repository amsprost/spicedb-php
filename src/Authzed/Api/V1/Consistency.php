<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: permission_service.proto

namespace Authzed\Api\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Consistency will define how a request is handled by the backend.
 * By defining a consistency requirement, and a token at which those
 * requirements should be applied, where applicable.
 *
 * Generated from protobuf message <code>authzed.api.v1.Consistency</code>
 */
class Consistency extends \Google\Protobuf\Internal\Message
{
    protected $requirement;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type bool $minimize_latency
     *           minimize_latency indicates that the latency for the call should be
     *           minimized by having the system select the fastest snapshot available.
     *     @type \Authzed\Api\V1\ZedToken $at_least_as_fresh
     *           at_least_as_fresh indicates that all data used in the API call must be
     *           *at least as fresh* as that found in the ZedToken; more recent data might
     *           be used if available or faster.
     *     @type \Authzed\Api\V1\ZedToken $at_exact_snapshot
     *           at_exact_snapshot indicates that all data used in the API call must be
     *           *at the given* snapshot in time; if the snapshot is no longer available,
     *           an error will be returned to the caller.
     *     @type bool $fully_consistent
     *           fully_consistent indicates that all data used in the API call *must* be
     *           at the most recent snapshot found.
     *           NOTE: using this method can be *quite slow*, so unless there is a need to
     *           do so, it is recommended to use `at_least_as_fresh` with a stored
     *           ZedToken.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\PermissionService::initOnce();
        parent::__construct($data);
    }

    /**
     * minimize_latency indicates that the latency for the call should be
     * minimized by having the system select the fastest snapshot available.
     *
     * Generated from protobuf field <code>bool minimize_latency = 1 [(.validate.rules) = {</code>
     * @return bool
     */
    public function getMinimizeLatency()
    {
        return $this->readOneof(1);
    }

    public function hasMinimizeLatency()
    {
        return $this->hasOneof(1);
    }

    /**
     * minimize_latency indicates that the latency for the call should be
     * minimized by having the system select the fastest snapshot available.
     *
     * Generated from protobuf field <code>bool minimize_latency = 1 [(.validate.rules) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setMinimizeLatency($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(1, $var);

        return $this;
    }

    /**
     * at_least_as_fresh indicates that all data used in the API call must be
     * *at least as fresh* as that found in the ZedToken; more recent data might
     * be used if available or faster.
     *
     * Generated from protobuf field <code>.authzed.api.v1.ZedToken at_least_as_fresh = 2;</code>
     * @return \Authzed\Api\V1\ZedToken|null
     */
    public function getAtLeastAsFresh()
    {
        return $this->readOneof(2);
    }

    public function hasAtLeastAsFresh()
    {
        return $this->hasOneof(2);
    }

    /**
     * at_least_as_fresh indicates that all data used in the API call must be
     * *at least as fresh* as that found in the ZedToken; more recent data might
     * be used if available or faster.
     *
     * Generated from protobuf field <code>.authzed.api.v1.ZedToken at_least_as_fresh = 2;</code>
     * @param \Authzed\Api\V1\ZedToken $var
     * @return $this
     */
    public function setAtLeastAsFresh($var)
    {
        GPBUtil::checkMessage($var, \Authzed\Api\V1\ZedToken::class);
        $this->writeOneof(2, $var);

        return $this;
    }

    /**
     * at_exact_snapshot indicates that all data used in the API call must be
     * *at the given* snapshot in time; if the snapshot is no longer available,
     * an error will be returned to the caller.
     *
     * Generated from protobuf field <code>.authzed.api.v1.ZedToken at_exact_snapshot = 3;</code>
     * @return \Authzed\Api\V1\ZedToken|null
     */
    public function getAtExactSnapshot()
    {
        return $this->readOneof(3);
    }

    public function hasAtExactSnapshot()
    {
        return $this->hasOneof(3);
    }

    /**
     * at_exact_snapshot indicates that all data used in the API call must be
     * *at the given* snapshot in time; if the snapshot is no longer available,
     * an error will be returned to the caller.
     *
     * Generated from protobuf field <code>.authzed.api.v1.ZedToken at_exact_snapshot = 3;</code>
     * @param \Authzed\Api\V1\ZedToken $var
     * @return $this
     */
    public function setAtExactSnapshot($var)
    {
        GPBUtil::checkMessage($var, \Authzed\Api\V1\ZedToken::class);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     * fully_consistent indicates that all data used in the API call *must* be
     * at the most recent snapshot found.
     * NOTE: using this method can be *quite slow*, so unless there is a need to
     * do so, it is recommended to use `at_least_as_fresh` with a stored
     * ZedToken.
     *
     * Generated from protobuf field <code>bool fully_consistent = 4 [(.validate.rules) = {</code>
     * @return bool
     */
    public function getFullyConsistent()
    {
        return $this->readOneof(4);
    }

    public function hasFullyConsistent()
    {
        return $this->hasOneof(4);
    }

    /**
     * fully_consistent indicates that all data used in the API call *must* be
     * at the most recent snapshot found.
     * NOTE: using this method can be *quite slow*, so unless there is a need to
     * do so, it is recommended to use `at_least_as_fresh` with a stored
     * ZedToken.
     *
     * Generated from protobuf field <code>bool fully_consistent = 4 [(.validate.rules) = {</code>
     * @param bool $var
     * @return $this
     */
    public function setFullyConsistent($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     * @return string
     */
    public function getRequirement()
    {
        return $this->whichOneof("requirement");
    }

}

